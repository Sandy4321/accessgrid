#! /bin/sh /usr/share/dpatch/dpatch-run
## servicesH264.dpatch by  <chris@v1.vislab.uq.edu.au>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad accessgrid3.1-3.1~/AccessGrid/packaging/servicesToShip accessgrid3.1-3.1/AccessGrid/packaging/servicesToShip
--- accessgrid3.1-3.1~/AccessGrid/packaging/servicesToShip	2004-05-21 06:57:25.000000000 +1000
+++ accessgrid3.1-3.1/AccessGrid/packaging/servicesToShip	2008-03-23 20:04:04.501138194 +1000
@@ -2,3 +2,6 @@
 AudioService
 VideoProducerService
 VideoConsumerService
+VideoServiceH264
+VideoProducerServiceH264
+VideoConsumerServiceH264
diff -urNad accessgrid3.1-3.1~/AccessGrid/services/node/VideoConsumerServiceH264/VideoConsumerServiceH264.build.py accessgrid3.1-3.1/AccessGrid/services/node/VideoConsumerServiceH264/VideoConsumerServiceH264.build.py
--- accessgrid3.1-3.1~/AccessGrid/services/node/VideoConsumerServiceH264/VideoConsumerServiceH264.build.py	1970-01-01 10:00:00.000000000 +1000
+++ accessgrid3.1-3.1/AccessGrid/services/node/VideoConsumerServiceH264/VideoConsumerServiceH264.build.py	2008-03-17 14:49:07.000000000 +1000
@@ -0,0 +1,65 @@
+#!/usr/bin/python2
+#
+# Build vic and copy it to the local dir
+#
+
+import sys, os
+
+SOURCE=sys.argv[1]
+AGDIR=sys.argv[2]
+DEST=sys.argv[3]
+
+# choices: ["openmash", "vic"]
+executableToBuild = "vic"
+
+servicesDir = os.path.join(AGDIR,'services','node')
+
+# Identify platform and set plat-specific bits
+if sys.platform == 'win32':
+    VIC_EXE = 'vic.exe'
+    vicFiles = [VIC_EXE]
+    copyExe = 'copy'
+elif sys.platform == 'linux2' or sys.platform == 'freebsd5' or sys.platform == 'freebsd6':
+    VIC_EXE = 'vic'
+    vicFiles = [VIC_EXE]
+    copyExe = 'cp'
+elif sys.platform == 'darwin':
+    if executableToBuild == "vic":
+        VIC_EXE = 'vic'
+        vicFiles = [VIC_EXE]
+        copyExe = 'cp -p'
+    elif executableToBuild == "openmash":
+        VIC_EXE = 'vic'
+        vicFiles = [VIC_EXE, 'mash', 'mash-5.3beta2']
+        copyExe = 'cp -p'
+else:
+    print "** Error: Unsupported platform by VideoConsumerService: " + sys.platform
+    
+VIC_EXE_PATH = os.path.join(servicesDir,VIC_EXE)
+
+# Build vic if necessary
+needBuild = 0
+for f in vicFiles:
+    if not os.path.exists(os.path.join(servicesDir,f)):
+        needBuild = 1
+        break
+
+needBuild = 0
+if needBuild:
+    # Build vic
+    if executableToBuild == "openmash":
+        buildCmd = '%s %s %s %s' % (sys.executable,
+                                os.path.join(AGDIR,'packaging','BuildMash.py'),
+                                SOURCE, servicesDir)
+    else:
+        buildCmd = '%s %s %s %s' % (sys.executable,
+                                os.path.join(AGDIR,'packaging','BuildVic.py'),
+                                SOURCE, servicesDir)
+    os.system(buildCmd)
+
+# Write the service manifest
+f = open('VideoConsumerServiceH264.manifest','w')
+f.write(VIC_EXE + '\n')
+f.close()
+
+
diff -urNad accessgrid3.1-3.1~/AccessGrid/services/node/VideoConsumerServiceH264/VideoConsumerServiceH264.py accessgrid3.1-3.1/AccessGrid/services/node/VideoConsumerServiceH264/VideoConsumerServiceH264.py
--- accessgrid3.1-3.1~/AccessGrid/services/node/VideoConsumerServiceH264/VideoConsumerServiceH264.py	1970-01-01 10:00:00.000000000 +1000
+++ accessgrid3.1-3.1/AccessGrid/services/node/VideoConsumerServiceH264/VideoConsumerServiceH264.py	2008-02-29 10:08:59.000000000 +1000
@@ -0,0 +1,247 @@
+#-----------------------------------------------------------------------------
+# Name:        VideoConsumerServiceH264.py
+# Purpose:
+# Created:     2003/06/02
+# RCS-ID:      $Id: VideoConsumerServiceH264.py,v 1.17 2007/09/12 07:01:56 douglask Exp $
+# Copyright:   (c) 2002
+# Licence:     See COPYING.TXT
+#-----------------------------------------------------------------------------
+import sys, os
+try:    import _winreg
+except: pass
+
+import agversion
+agversion.select(3)
+from AccessGrid import Toolkit
+
+from AccessGrid.Descriptions import Capability
+from AccessGrid.AGService import AGService
+from AccessGrid.AGParameter import ValueParameter, OptionSetParameter, RangeParameter
+from AccessGrid.Platform import IsWindows, IsLinux, IsFreeBSD, IsOSX
+from AccessGrid.Platform.Config import AGTkConfig, UserConfig, SystemConfig
+from AccessGrid.NetworkLocation import MulticastNetworkLocation
+
+class VideoConsumerServiceH264( AGService ):
+
+    tileOptions = [ '1', '2', '3', '4', '5', '6', '7', '8', '9', '10' ]
+
+    def __init__( self ):
+        AGService.__init__( self )
+        self.capabilities = [  #Capability( Capability.CONSUMER,
+                               #           Capability.VIDEO,
+                               #           "H261",
+                               #           90000, self.id) ,
+                                Capability( Capability.CONSUMER,
+                                          Capability.VIDEO,
+                                          "H264",
+                                          90000, self.id),
+                                Capability( Capability.CONSUMER,
+                                          Capability.VIDEO,
+                                          "MPEG4",
+                                          90000, self.id),
+                                Capability( Capability.CONSUMER,
+                                          Capability.VIDEO,
+                                          "H261AS",
+                                          90000, self.id) 
+                                          ]
+
+        if IsWindows():
+            vic = "vic.exe"
+        else:
+            vic = "vic"
+
+        self.executable = os.path.join(os.getcwd(),vic)
+        if not os.path.isfile(self.executable):
+            self.executable = vic
+
+        self.sysConf = SystemConfig.instance()
+
+        self.profile = None
+
+        self.startPriority = '7'
+        self.startPriorityOption.value = self.startPriority
+
+        # Set configuration parameters
+        self.tiles = OptionSetParameter( "Thumbnail Columns", "2", VideoConsumerServiceH264.tileOptions )
+        self.configuration.append( self.tiles )
+
+        if IsWindows():
+            try:
+                import win32api
+
+                # get number of processors
+                systemInfo = win32api.GetSystemInfo()
+                numprocs = systemInfo[5]
+                self.allProcsMask = 2**numprocs-1
+
+                self.procOptions = ['All']
+                for i in range(numprocs):
+                    self.procOptions.append(str(i+1))
+
+                self.processorUsage = OptionSetParameter( "Processor usage", self.procOptions[0], self.procOptions )
+                self.configuration.append( self.processorUsage )
+            except:
+                self.log.exception('Error initializing processor usage options')
+
+
+    def __SetRTPDefaults(self, profile):
+        """
+        Set values used by rat for identification
+        """
+        if profile == None:
+            self.log.exception("Invalid profile (None)")
+            raise Exception, "Can't set RTP Defaults without a valid profile."
+
+        if IsLinux() or IsOSX() or IsFreeBSD():
+            try:
+                rtpDefaultsFile=os.path.join(os.environ["HOME"], ".RTPdefaults")
+                rtpDefaultsText="*rtpName: %s\n*rtpEmail: %s\n*rtpLoc: %s\n*rtpPhone: \
+                                 %s\n*rtpNote: %s\n"
+                rtpDefaultsFH=open( rtpDefaultsFile,"w")
+                rtpDefaultsFH.write( rtpDefaultsText % ( profile.name,
+                                       profile.email,
+                                       profile.location,
+                                       profile.phoneNumber,
+                                       profile.publicId ) )
+                rtpDefaultsFH.close()
+            except:
+                self.log.exception("Error writing RTP defaults file: %s", rtpDefaultsFile)
+
+        elif IsWindows():
+            try:
+                # Set RTP defaults according to the profile
+                k = _winreg.CreateKey(_winreg.HKEY_CURRENT_USER,
+                                    r"Software\Mbone Applications\common")
+
+                # Vic reads these values (with '*')
+                _winreg.SetValueEx(k, "*rtpName", 0,
+                                   _winreg.REG_SZ, profile.name)
+                _winreg.SetValueEx(k, "*rtpEmail", 0,
+                                   _winreg.REG_SZ, profile.email)
+                _winreg.SetValueEx(k, "*rtpPhone", 0,
+                                   _winreg.REG_SZ, profile.phoneNumber)
+                _winreg.SetValueEx(k, "*rtpLoc", 0,
+                                   _winreg.REG_SZ, profile.location)
+                _winreg.SetValueEx(k, "*rtpNote", 0,
+                                   _winreg.REG_SZ, str(profile.publicId) )
+                _winreg.CloseKey(k)
+            except:
+                self.log.exception("Error writing RTP defaults to registry")
+        else:
+            self.log.error("No support for platform: %s", sys.platform)
+            
+        
+    def Start( self ):
+        """Start service"""
+        try:
+
+            # Set processor affinity (windows only)
+            if IsWindows():
+                try:
+                    if self.processorUsage.value == 'All':
+                        self.log.info('Setting processor affinity to all processors')
+                        SystemConfig.instance().SetProcessorAffinity(self.allProcsMask)
+                    else:
+                        val = 2**(int(self.processorUsage.value)-1)
+                        self.log.info('Ssetting processor affinity : use processor %s', self.processorUsage.value)
+                        SystemConfig.instance().SetProcessorAffinity(int(self.processorUsage.value))
+                except:
+                    self.log.exception("Exception setting processor affinity")
+
+            # Enable firewall
+            self.sysConf.AppFirewallConfig(self.executable, 1)
+
+            # Start the service; in this case, store command line args
+            # in a list and let the superclass _Start the service
+            options = []
+            if self.streamDescription.name and \
+                   len(self.streamDescription.name.strip()) > 0:
+                options.append( "-C" )
+                options.append( self.streamDescription.name )
+            if self.streamDescription.encryptionFlag != 0:
+                options.append( "-K" )
+                options.append( self.streamDescription.encryptionKey )
+            # Check whether the network location has a "type"
+            # attribute Note: this condition is only to maintain
+            # compatibility between older venue servers creating
+            # network locations without this attribute and newer
+            # services relying on the attribute; it should be removed
+            # when the incompatibility is gone
+            if self.streamDescription.location.__dict__.has_key("type"):
+                if self.streamDescription.location.type == MulticastNetworkLocation.TYPE:
+                    options.append( "-t" )
+                    options.append( '%d' % ( self.streamDescription.location.ttl ) )
+
+            # Set name and email on command line, in case rtp defaults
+            # haven't been written (to avoid vic prompting for
+            # name/email)
+            name=email="Participant"
+            if self.profile:
+                name = self.profile.name
+                email = self.profile.email
+            options.append('-XrtpName=%s' % (name,))
+            options.append('-XrtpEmail=%s' % (email,))
+
+            # Set some tk resources to customize vic
+            # - this is a consumer, so disable device selection in vic
+            options.append('-XrecvOnly=1')
+            # - set drop time to something reasonable
+            options.append('-XsiteDropTime=5')
+            # - set vic window geometry
+            options.append('-Xgeometry=500x500')
+            # - set number of columns of thumbnails to display
+            options.append('-Xtile=%s' % self.tiles.value)
+                    
+            # Add address/port options (these must occur last; don't
+            # add options beyond here)
+            options.append( '%s/%d' % (self.streamDescription.location.host,
+                                       self.streamDescription.location.port))
+            self.log.info("Starting VideoConsumerServiceH264")
+            self.log.info(" executable = %s" % self.executable)
+            self.log.info(" options = %s" % options)
+            self._Start( options )
+        except:
+            self.log.exception("Exception in VideoConsumerServiceH264.Start")
+            raise Exception("Failed to start service")
+
+    def Stop( self ):
+        """Stop the service"""
+
+        # vic doesn't die easily (on linux at least), so force it to stop
+        AGService.ForceStop(self)
+
+        # Disable firewall
+        self.sysConf.AppFirewallConfig(self.executable, 0)
+
+    def SetStream( self, streamDescription ):
+        """Configure the Service according to the StreamDescription"""
+
+        ret = AGService.ConfigureStream( self, streamDescription )
+        if ret and self.started:
+            # service is already running with this config; ignore
+            return
+
+        # if started, stop
+        if self.started:
+            self.Stop()
+
+        # if enabled, start
+        if self.enabled:
+            self.Start()
+
+    def SetIdentity(self, profile):
+        """
+        Set the identity of the user driving the node
+        """
+        self.log.info("SetIdentity: %s %s", profile.name, profile.email)
+        self.profile = profile
+        self.__SetRTPDefaults(profile)
+
+if __name__ == '__main__':
+
+    from AccessGrid.interfaces.AGService_interface import AGService as AGServiceI
+    from AccessGrid.AGService import RunService
+
+    service = VideoConsumerServiceH264()
+    serviceI = AGServiceI(service)
+    RunService(service,serviceI)
diff -urNad accessgrid3.1-3.1~/AccessGrid/services/node/VideoConsumerServiceH264/VideoConsumerServiceH264.svc accessgrid3.1-3.1/AccessGrid/services/node/VideoConsumerServiceH264/VideoConsumerServiceH264.svc
--- accessgrid3.1-3.1~/AccessGrid/services/node/VideoConsumerServiceH264/VideoConsumerServiceH264.svc	1970-01-01 10:00:00.000000000 +1000
+++ accessgrid3.1-3.1/AccessGrid/services/node/VideoConsumerServiceH264/VideoConsumerServiceH264.svc	2008-02-28 07:34:29.000000000 +1000
@@ -0,0 +1,12 @@
+[ServiceDescription]
+name = VideoConsumerServiceH264
+description = Vic-based video service to receive mpeg4 and h264 video
+capabilities = Capability1
+executable = VideoConsumerServiceH264.py
+platform = neutral
+version = 3.1
+
+[Capability1]
+role = consumer
+type = video
+
diff -urNad accessgrid3.1-3.1~/AccessGrid/services/node/VideoProducerServiceH264/VideoProducerServiceH264.build.py accessgrid3.1-3.1/AccessGrid/services/node/VideoProducerServiceH264/VideoProducerServiceH264.build.py
--- accessgrid3.1-3.1~/AccessGrid/services/node/VideoProducerServiceH264/VideoProducerServiceH264.build.py	1970-01-01 10:00:00.000000000 +1000
+++ accessgrid3.1-3.1/AccessGrid/services/node/VideoProducerServiceH264/VideoProducerServiceH264.build.py	2008-03-17 14:48:40.000000000 +1000
@@ -0,0 +1,66 @@
+#!/usr/bin/python2
+#
+# Build vic and copy it to the local dir
+#
+
+import sys, os
+
+SOURCE=sys.argv[1]
+AGDIR=sys.argv[2]
+DEST=sys.argv[3]
+
+# choices: ["openmash", "vic"]
+executableToBuild = "vic"
+
+servicesDir = os.path.join(AGDIR,'services','node')
+
+# Identify platform and set plat-specific bits
+if sys.platform == 'win32':
+    VIC_EXE = 'vic.exe'
+    vicFiles = [VIC_EXE]
+    copyExe = 'copy'
+elif sys.platform == 'linux2' or sys.platform == 'freebsd5' or sys.platform == 'freebsd6':
+    VIC_EXE = 'vic'
+    vicFiles = [VIC_EXE]
+    copyExe = 'cp'
+elif sys.platform == 'darwin':  
+    if executableToBuild == "vic":
+        VIC_EXE = 'vic'
+        vicFiles = [VIC_EXE]
+        copyExe = 'cp -p'
+    elif executableToBuild == "openmash":
+        VIC_EXE = 'vic'
+        vicFiles = [VIC_EXE, 'mash', 'mash-5.3beta2']
+        copyExe = 'cp -p'
+else:
+    print "** Error: Unsupported platform: " + sys.platform
+    
+
+VIC_EXE_PATH = os.path.join(servicesDir,VIC_EXE)
+
+# Build vic if necessary
+needBuild = 0
+for f in vicFiles:
+    if not os.path.exists(os.path.join(servicesDir,f)):
+        needBuild = 1
+        break
+
+needBuild = 0
+if needBuild:
+    # Build vic
+    if executableToBuild == "openmash":
+        buildCmd = '%s %s %s %s' % (sys.executable,
+                                os.path.join(AGDIR,'packaging','BuildMash.py'),
+                                SOURCE, servicesDir)
+    else:
+        buildCmd = '%s %s %s %s' % (sys.executable,
+                                os.path.join(AGDIR,'packaging','BuildVic.py'),
+                                SOURCE,servicesDir)
+    os.system(buildCmd)
+
+# Write the service manifest
+f = open('VideoProducerServiceH264.manifest','w')
+f.write(VIC_EXE + '\n')
+f.close()
+
+
diff -urNad accessgrid3.1-3.1~/AccessGrid/services/node/VideoProducerServiceH264/VideoProducerServiceH264.py accessgrid3.1-3.1/AccessGrid/services/node/VideoProducerServiceH264/VideoProducerServiceH264.py
--- accessgrid3.1-3.1~/AccessGrid/services/node/VideoProducerServiceH264/VideoProducerServiceH264.py	1970-01-01 10:00:00.000000000 +1000
+++ accessgrid3.1-3.1/AccessGrid/services/node/VideoProducerServiceH264/VideoProducerServiceH264.py	2008-03-23 19:56:00.000000000 +1000
@@ -0,0 +1,460 @@
+#-----------------------------------------------------------------------------
+# Name:        VideoProducerServiceH264.py
+# Purpose:
+# Created:     2003/06/02
+# RCS-ID:      $Id: VideoProducerServiceH264.py,v 1.26 2007/10/01 17:28:56 turam Exp $
+# Copyright:   (c) 2002
+# Licence:     See COPYING.TXT
+#-----------------------------------------------------------------------------
+import re
+import sys, os
+
+try:   
+    import _winreg
+except: pass
+
+from AccessGrid import Toolkit
+
+from AccessGrid.Descriptions import Capability, ResourceDescription
+from AccessGrid.AGService import AGService
+from AccessGrid.AGParameter import ValueParameter, OptionSetParameter, RangeParameter, TextParameter
+from AccessGrid.Platform import IsWindows, IsLinux, IsOSX, IsFreeBSD
+from AccessGrid.Platform.Config import AGTkConfig, UserConfig, SystemConfig
+from AccessGrid.NetworkLocation import MulticastNetworkLocation
+
+vicstartup="""option add Vic.disable_autoplace true startupFile
+option add Vic.muteNewSources true startupFile
+option add Vic.maxbw 6144 startupFile
+option add Vic.bandwidth %d startupFile
+option add Vic.framerate %d startupFile
+option add Vic.quality %d startupFile
+option add Vic.defaultFormat %s startupFile
+option add Vic.inputType %s startupFile
+option add Vic.device \"%s\" startupFile
+option add Vic.defaultTTL 127 startupFile
+option add Vic.rtpName \"%s\" startupFile
+option add Vic.rtpEmail \"%s\" startupFile
+proc user_hook {} {
+    global videoDevice inputPort transmitButton transmitButtonState sizeButtons inputSize
+
+    update_note 0 \"%s\"
+
+    after 200 {
+        if { ![winfo exists .menu] } {
+            build.menu
+        }
+ 
+        set inputPort \"%s\"
+        grabber port \"%s\"
+
+        set inputSize %d
+
+        if { [$transmitButton cget -state] != \"disabled\" } {
+            set transmitButtonState 1
+            transmit
+        }
+    }
+}
+"""
+
+class VideoProducerServiceH264( AGService ):
+
+    encodings = [ "mpeg4","h264","h261as" ]
+    standards = [ "NTSC", "PAL", "auto" ]
+    inputsizes = [ "Small", "Normal", "Large" ]
+
+    def __init__( self ):
+        AGService.__init__( self )
+        self.capabilities = [ Capability( Capability.PRODUCER,
+                                          Capability.VIDEO,
+                                          "MPEG4",
+                                          90000,self.id),
+                               Capability( Capability.PRODUCER,
+                                          Capability.VIDEO,
+                                          "H264",
+                                          90000,self.id),
+                               #Capability( Capability.PRODUCER,
+                               #           Capability.VIDEO,
+                               #           "H261",
+                               #           90000,self.id),
+                               Capability( Capability.PRODUCER,
+                                          Capability.VIDEO,
+                                          "H261AS",
+                                          90000,self.id)                                          ]
+        
+        if IsWindows():
+            vic = "vic.exe"
+        else:
+            vic = "vic"
+
+        self.executable = os.path.join(os.getcwd(),vic)
+        if not os.path.isfile(self.executable):
+            self.executable = vic
+
+        self.sysConf = SystemConfig.instance()
+
+        self.startPriority = '5'
+        self.startPriorityOption.value = self.startPriority
+
+
+        # Set configuration parameters
+
+        # note: the datatype of the port parameter changes when a resource is set!
+        self.streamname = TextParameter( "Stream Name", "" )
+        self.port = TextParameter( "Port", "" )
+        self.encoding = OptionSetParameter( "Encoding", "mpeg4", VideoProducerServiceH264.encodings )
+        if IsWindows(): 
+            standard = "PAL"
+        else:
+            standard = "auto"
+        self.standard = OptionSetParameter( "Standard", standard, VideoProducerServiceH264.standards )
+        self.bandwidth = RangeParameter( "Bandwidth", 4096, 0, 6144 )
+        self.framerate = RangeParameter( "Frame Rate", 24, 1, 30 )
+        self.quality = RangeParameter( "Quality", 75, 1, 100 )
+        self.inputsize = OptionSetParameter( "Capture Size", "Large", VideoProducerServiceH264.inputsizes  )
+        self.configuration.append( self.streamname )
+        self.configuration.append( self.port )
+        self.configuration.append( self.encoding )
+        self.configuration.append( self.standard )
+        self.configuration.append( self.bandwidth )
+        self.configuration.append( self.framerate )
+        self.configuration.append (self.quality )
+        self.configuration.append (self.inputsize )
+
+        if IsWindows():
+            try:
+                import win32api
+
+                # get number of processors
+                systemInfo = win32api.GetSystemInfo()
+                numprocs = systemInfo[5]
+                self.allProcsMask = 2**numprocs-1
+
+                self.procOptions = ['All']
+                for i in range(numprocs):
+                    self.procOptions.append(str(i+1))
+
+                self.processorUsage = OptionSetParameter( "Processor usage", self.procOptions[0], self.procOptions )
+                self.configuration.append( self.processorUsage )
+            except:
+                self.log.exception('Error initializing processor usage options')
+
+        self.profile = None
+        self.resource = ''
+        
+        self.__GetResources()
+
+    def __SetRTPDefaults(self, profile):
+        """
+        Set values used by rat for identification
+        """
+        if profile == None:
+            self.log.exception("Invalid profile (None)")
+            raise Exception, "Can't set RTP Defaults without a valid profile."
+
+        if IsLinux() or IsOSX() or IsFreeBSD():
+            try:
+                rtpDefaultsFile=os.path.join(os.environ["HOME"], ".RTPdefaults")
+                rtpDefaultsText="*rtpName: %s\n*rtpEmail: %s\n*rtpLoc: %s\n*rtpPhone: \
+                                 %s\n*rtpNote: %s\n"
+                rtpDefaultsFH=open( rtpDefaultsFile,"w")
+                rtpDefaultsFH.write( rtpDefaultsText % ( profile.name,
+                                       profile.email,
+                                       profile.location,
+                                       profile.phoneNumber,
+                                       profile.publicId ) )
+                rtpDefaultsFH.close()
+            except:
+                self.log.exception("Error writing RTP defaults file: %s", rtpDefaultsFile)
+
+        elif IsWindows():
+            try:
+                #
+                # Set RTP defaults according to the profile
+                #
+                k = _winreg.CreateKey(_winreg.HKEY_CURRENT_USER,
+                                    r"Software\Mbone Applications\common")
+
+                # Vic reads these values (with '*')
+                _winreg.SetValueEx(k, "*rtpName", 0,
+                                   _winreg.REG_SZ, profile.name)
+                _winreg.SetValueEx(k, "*rtpEmail", 0,
+                                   _winreg.REG_SZ, profile.email)
+                _winreg.SetValueEx(k, "*rtpPhone", 0,
+                                   _winreg.REG_SZ, profile.phoneNumber)
+                _winreg.SetValueEx(k, "*rtpLoc", 0,
+                                   _winreg.REG_SZ, profile.location)
+                _winreg.SetValueEx(k, "*rtpNote", 0,
+                                   _winreg.REG_SZ, str(profile.publicId) )
+                _winreg.CloseKey(k)
+            except:
+                self.log.exception("Error writing RTP defaults to registry")
+        else:
+            self.log.error("No support for platform: %s", sys.platform)
+        
+    def MapWinDevice(self,deviceStr):
+        """
+        Abuse registry to get correct mapping from vfw names
+        to video sources
+        """
+        videowidth = 720
+        videoheight = 480
+        
+        self.log.info("Mapping windows device: %s", deviceStr)
+        if deviceStr.find('Videum') >= 0:
+            self.log.info("- videum")
+            devnum = -1
+            videum_re = re.compile(".*(\d)_Videum.*")
+            m = videum_re.search(deviceStr)
+            if m:
+                self.log.info("Found match : %d", int(m.group(1)))
+                devnum = int(m.group(1))
+            else:
+                self.log.info("No match")
+                if deviceStr.startswith('Videum Video Capture'):
+                    self.log.info("is videum video capture")
+                    devnum = 0
+                else:
+                    self.log.info("is not videum video capture")
+
+            self.log.info("Videum device: %d", devnum)
+            if devnum >= 0:
+                # Set the registry
+                keyStr = r"Software\Winnov\Videum\vic.exe%d" % (devnum,)
+                key = _winreg.CreateKey(_winreg.HKEY_CURRENT_USER,
+                                        keyStr)
+                _winreg.SetValueEx(key,'Source',0,_winreg.REG_DWORD,int(devnum))
+                _winreg.SetValueEx(key,'Height',0,_winreg.REG_DWORD,int(videoheight))
+                _winreg.SetValueEx(key,'Width',0,_winreg.REG_DWORD,int(videowidth))
+                _winreg.CloseKey(key)
+                
+
+    def Start( self ):
+        """Start service"""
+        try:
+
+            # Set processor affinity (windows only)
+            if IsWindows():
+                try:
+                    if self.processorUsage.value == 'All':
+                        self.log.info('Setting processor affinity to all processors')
+                        SystemConfig.instance().SetProcessorAffinity(self.allProcsMask)
+                    else:
+                        val = 2**(int(self.processorUsage.value)-1)
+                        self.log.info('Ssetting processor affinity : use processor %s', self.processorUsage.value)
+                        SystemConfig.instance().SetProcessorAffinity(int(self.processorUsage.value))
+                except:
+                    self.log.exception("Exception setting processor affinity")
+            
+            # Enable firewall
+            self.sysConf.AppFirewallConfig(self.executable, 1)
+
+            # Resolve assigned resource to a device understood by vic
+            if self.resource == "None":
+                vicDevice = "None"
+            else:
+                vicDevice = self.resource[0]
+                vicDevice = vicDevice.replace("[","\[")
+                vicDevice = vicDevice.replace("]","\]")
+
+            if IsWindows():
+                try:
+                    self.MapWinDevice(self.resource[0])
+                except:
+                    self.log.exception("Exception mapping device")
+
+
+            #
+            # Write vic startup file
+            #
+            startupfile = os.path.join(UserConfig.instance().GetTempDir(),
+               'VideoProducerServiceH264_%d.vic' % ( os.getpid() ) )
+
+            f = open(startupfile,"w")
+            if self.port.value == '':
+                portstr = "None"
+            else:
+                portstr = self.port.value
+            
+            name=email="Participant"
+            if self.profile:
+                name = self.profile.name
+                email = self.profile.email
+            else:
+                # Error case
+                name = email = Toolkit.GetDefaultSubject().GetCN()
+                self.log.error("Starting service without profile set")
+
+            if self.inputsize.value == "Small":
+                inputsize = 4
+            elif self.inputsize.value == "Normal":
+                inputsize = 2
+            elif self.inputsize.value == "Large":
+                if self.encoding.value == "h261":
+                    self.log.warn("Invalid capture size (large) specified for h261 encoding; defaulting to normal size")
+                    inputsize = 2
+                else:
+                    inputsize = 1
+                
+            f.write( vicstartup % (self.bandwidth.value,
+                                    self.framerate.value,
+                                    self.quality.value,
+                                    self.encoding.value,
+                                    self.standard.value,
+                                    vicDevice,
+                                    "%s(%s)" % (name,self.streamname.value),
+                                    email,
+                                    email,
+                                    portstr,
+                                    portstr,
+                                    inputsize) )
+            f.close()
+            
+            # Open permissions on vic startupfile
+            os.chmod(startupfile,0777)
+
+            # Replace double backslashes in the startupfile name with single
+            #  forward slashes (vic will crash otherwise)
+            if IsWindows():
+                startupfile = startupfile.replace("\\","/")
+            
+            #
+            # Start the service; in this case, store command line args in a list and let
+            # the superclass _Start the service
+            options = []
+            options.append( "-u" )
+            options.append( startupfile )
+            options.append( "-C" )
+            options.append( str(self.streamname.value) )
+            if IsOSX():
+                options.append( "-X")
+                options.append( "transmitOnStartup=1")
+            if self.streamDescription.encryptionFlag != 0:
+                options.append( "-K" )
+                options.append( self.streamDescription.encryptionKey )
+                
+            if self.profile:
+                options.append("-X")
+                options.append("site=%s" % self.profile.publicId)
+                
+            # Check whether the network location has a "type" attribute
+            # Note: this condition is only to maintain compatibility between
+            # older venue servers creating network locations without this attribute
+            # and newer services relying on the attribute; it should be removed
+            # when the incompatibility is gone
+            if self.streamDescription.location.__dict__.has_key("type"):
+                # use TTL from multicast locations only
+                if self.streamDescription.location.type == MulticastNetworkLocation.TYPE:
+                    options.append( "-t" )
+                    options.append( '%d' % (self.streamDescription.location.ttl) )
+            options.append( '%s/%d' % ( self.streamDescription.location.host,
+                                           self.streamDescription.location.port) )
+
+            self.log.info("Starting VideoProducerServiceH264")
+            self.log.info(" executable = %s" % self.executable)
+            self.log.info(" options = %s" % options)
+            self._Start( options )
+            #os.remove(startupfile)
+        except:
+            self.log.exception("Exception in VideoProducerServiceH264.Start")
+            raise Exception("Failed to start service")
+
+    def Stop( self ):
+        """Stop the service"""
+
+        # vic doesn't die easily (on linux at least), so force it to stop
+        AGService.ForceStop(self)
+
+        # Disable firewall
+        self.sysConf.AppFirewallConfig(self.executable, 0)
+
+    def SetStream( self, streamDescription ):
+        """Configure the Service according to the StreamDescription"""
+        self.log.info('SetStream: %s', streamDescription)
+        self.log.info('  enabled: %d', self.enabled)
+
+        ret = AGService.ConfigureStream( self, streamDescription )
+        if ret and self.started:
+            # service is already running with this config; ignore
+            return
+
+        # if started, stop
+        if self.started:
+            self.Stop()
+
+        # if enabled, start
+        if self.enabled:
+            self.Start()
+
+    def GetResource( self ):
+        if self.resource:
+            return ResourceDescription(self.resource[0])
+        else:
+            return ResourceDescription('')
+
+    def SetResource( self, resource ):
+        """Set the resource used by this service"""
+
+        self.log.info("VideoProducerServiceH264.SetResource : %s" % resource.name)
+        for r in self.resources:
+            if r[0].strip() == resource.name:
+                self.resource = r
+
+        # Find the config element that refers to "port"
+        try:
+            index = self.configuration.index(self.port)
+            found = 1
+        except ValueError:
+            found = 0
+
+        # Create the port parameter as an option set parameter, now
+        # that we have multiple possible values for "port"
+        # If self.port is valid, keep it instead of setting the default value.
+        if (( isinstance(self.port, TextParameter) or isinstance(self.port, ValueParameter) ) 
+              and self.port.value != "" and self.port.value in self.resource[1]):
+            self.port = OptionSetParameter( "Port", self.port.value,
+                                                         self.resource[1] )
+        else:
+            self.port = OptionSetParameter( "Port", self.resource[1][0],
+                                                         self.resource[1] )
+
+        self.log.info('port = %s', self.port.value)
+
+        # Replace or append the "port" element
+        if found:
+            self.configuration[index] = self.port
+        else:
+            self.configuration.append(self.port)
+
+        # If the stream name has not been set, set it to the resource name
+        if not self.streamname.value:
+            self.streamname.value = resource.name
+
+    def SetIdentity(self, profile):
+        """
+        Set the identity of the user driving the node
+        """
+        self.log.info("SetIdentity: %s %s", profile.name, profile.email)
+        self.profile = profile
+        self.__SetRTPDefaults(profile)
+        
+    def GetResources(self):
+        ret = map(lambda x: ResourceDescription(x[0]) , self.resources)
+        self.log.info('resources: %s', ret)
+        return ret
+
+    def __GetResources(self):
+        self.resources = SystemConfig.instance().GetResources()
+        return self.resources
+        
+
+
+
+if __name__ == '__main__':
+
+    from AccessGrid.interfaces.AGService_interface import AGService as AGServiceI
+    from AccessGrid.AGService import RunService
+
+    service = VideoProducerServiceH264()
+    serviceI = AGServiceI(service)
+    RunService(service,serviceI)
diff -urNad accessgrid3.1-3.1~/AccessGrid/services/node/VideoProducerServiceH264/VideoProducerServiceH264.svc accessgrid3.1-3.1/AccessGrid/services/node/VideoProducerServiceH264/VideoProducerServiceH264.svc
--- accessgrid3.1-3.1~/AccessGrid/services/node/VideoProducerServiceH264/VideoProducerServiceH264.svc	1970-01-01 10:00:00.000000000 +1000
+++ accessgrid3.1-3.1/AccessGrid/services/node/VideoProducerServiceH264/VideoProducerServiceH264.svc	2008-02-29 10:35:20.000000000 +1000
@@ -0,0 +1,12 @@
+[ServiceDescription]
+name = VideoProducerServiceH264
+description = Vic-based video service using h264 and mpeg4
+capabilities = Capability1
+executable = VideoProducerServiceH264.py
+platform = neutral
+version = 3.11
+
+[Capability1]
+role = producer
+type = video
+
diff -urNad accessgrid3.1-3.1~/AccessGrid/services/node/VideoServiceH264/VideoServiceH264.build.py accessgrid3.1-3.1/AccessGrid/services/node/VideoServiceH264/VideoServiceH264.build.py
--- accessgrid3.1-3.1~/AccessGrid/services/node/VideoServiceH264/VideoServiceH264.build.py	1970-01-01 10:00:00.000000000 +1000
+++ accessgrid3.1-3.1/AccessGrid/services/node/VideoServiceH264/VideoServiceH264.build.py	2008-03-17 14:48:10.000000000 +1000
@@ -0,0 +1,66 @@
+#!/usr/bin/python2
+#
+# Build vic and copy it to the local dir
+#
+
+import sys, os
+
+SOURCE=sys.argv[1]
+AGDIR=sys.argv[2]
+DEST=sys.argv[3]
+
+# choices: ["openmash", "vic"]
+executableToBuild = "vic"
+
+servicesDir = os.path.join(AGDIR,'services','node')
+
+# Identify platform and set plat-specific bits
+if sys.platform == 'win32':
+    VIC_EXE = 'vic.exe'
+    vicFiles = [VIC_EXE]
+    copyExe = 'copy'
+elif sys.platform == 'linux2' or sys.platform == 'freebsd5' or sys.platform == 'freebsd6':
+    VIC_EXE = 'vic'
+    vicFiles = [VIC_EXE]
+    copyExe = 'cp'
+elif sys.platform == 'darwin':
+    if executableToBuild == "vic":
+        VIC_EXE = 'vic'
+        vicFiles = [VIC_EXE]
+        copyExe = 'cp -p'
+    elif executableToBuild == "openmash":
+        VIC_EXE = 'vic'
+        vicFiles = [VIC_EXE, 'mash', 'mash-5.3beta2']
+        copyExe = 'cp -p'
+else:
+    print "** Error: Unsupported platform: " + sys.platform
+    
+
+VIC_EXE_PATH = os.path.join(servicesDir,VIC_EXE)
+
+# Build vic if necessary
+needBuild = 0
+for f in vicFiles:
+    if not os.path.exists(os.path.join(servicesDir,f)):
+        needBuild = 1
+        break
+
+needBuild = 0
+if needBuild:
+    # Build vic
+    if executableToBuild == "openmash":
+        buildCmd = '%s %s %s %s' % (sys.executable,
+                                os.path.join(AGDIR,'packaging','BuildMash.py'),
+                                SOURCE, servicesDir)
+    else:
+        buildCmd = '%s %s %s %s' % (sys.executable,
+                                os.path.join(AGDIR,'packaging','BuildVic.py'),
+                                SOURCE, servicesDir)
+    os.system(buildCmd)
+
+# Write the service manifest
+f = open('VideoServiceH264.manifest','w')
+f.write(VIC_EXE + '\n')
+f.close()
+
+
diff -urNad accessgrid3.1-3.1~/AccessGrid/services/node/VideoServiceH264/VideoServiceH264.py accessgrid3.1-3.1/AccessGrid/services/node/VideoServiceH264/VideoServiceH264.py
--- accessgrid3.1-3.1~/AccessGrid/services/node/VideoServiceH264/VideoServiceH264.py	1970-01-01 10:00:00.000000000 +1000
+++ accessgrid3.1-3.1/AccessGrid/services/node/VideoServiceH264/VideoServiceH264.py	2008-03-23 19:52:15.000000000 +1000
@@ -0,0 +1,503 @@
+#-----------------------------------------------------------------------------
+# Name:        VideoServiceH264.py
+# Purpose:
+# Created:     2003/06/02
+# RCS-ID:      $Id: VideoServiceH264.py,v 1.26 2007/10/01 17:28:56 turam Exp $
+# Copyright:   (c) 2002
+# Licence:     See COPYING.TXT
+#-----------------------------------------------------------------------------
+import re
+import sys, os
+
+try:   
+    import _winreg
+except: pass
+
+from AccessGrid import Toolkit
+
+from AccessGrid.Descriptions import Capability, ResourceDescription
+from AccessGrid.AGService import AGService
+from AccessGrid.AGParameter import ValueParameter, OptionSetParameter, RangeParameter, TextParameter
+from AccessGrid.Platform import IsWindows, IsLinux, IsOSX, IsFreeBSD
+from AccessGrid.Platform.Config import AGTkConfig, UserConfig, SystemConfig
+from AccessGrid.NetworkLocation import MulticastNetworkLocation
+
+vicstartup="""option add Vic.disable_autoplace %s startupFile
+option add Vic.muteNewSources %s startupFile
+option add Vic.maxbw 6144 startupFile
+option add Vic.bandwidth %d startupFile
+option add Vic.framerate %d startupFile
+option add Vic.quality %d startupFile
+option add Vic.defaultFormat %s startupFile
+option add Vic.inputType %s startupFile
+option add Vic.device \"%s\" startupFile
+option add Vic.defaultTTL 127 startupFile
+option add Vic.rtpName \"%s\" startupFile
+option add Vic.rtpEmail \"%s\" startupFile
+proc user_hook {} {
+    global videoDevice inputPort transmitButton transmitButtonState sizeButtons inputSize
+
+    update_note 0 \"%s\"
+
+    after 200 {
+        set transmitOnStartup %s
+
+        if { ![winfo exists .menu] } {
+            build.menu
+        }
+ 
+        set inputPort \"%s\"
+        grabber port \"%s\"
+
+        set inputSize %d
+
+        if { [$transmitButton cget -state] != \"disabled\" } {
+            set transmitButtonState 1
+            transmit
+        }
+    }
+}
+"""
+
+def OnOff(onOffVal):
+    if onOffVal == "On":
+        return "true"
+    elif onOffVal == "Off":
+        return "false"
+    raise Exception,"OnOff value neither On nor Off: %s" % onOffVal
+
+class VideoServiceH264( AGService ):
+
+    encodings = [ "mpeg4","h264","h261as" ]
+    standards = [ "NTSC", "PAL", "auto" ]
+    inputsizes = [ "Small", "Normal", "Large" ]
+    onOffOptions = [ "On", "Off" ]
+    tileOptions = [ '1', '2', '3', '4', '5', '6', '7', '8', '9', '10' ]
+
+    def __init__( self ):
+        AGService.__init__( self )
+        self.capabilities = [ Capability( Capability.CONSUMER,
+                                          Capability.VIDEO,
+                                          "MPEG4",
+                                          90000,self.id),
+                               Capability( Capability.PRODUCER,
+                                          Capability.VIDEO,
+                                          "MPEG4",
+                                          90000,self.id),
+                               Capability( Capability.CONSUMER,
+                                          Capability.VIDEO,
+                                          "H264",
+                                          90000,self.id),
+                               Capability( Capability.PRODUCER,
+                                          Capability.VIDEO,
+                                          "H264",
+                                          90000,self.id),
+                               #Capability( Capability.PRODUCER,
+                               #           Capability.VIDEO,
+                               #           "H261",
+                               #           90000,self.id),
+                               Capability( Capability.CONSUMER,
+                                          Capability.VIDEO,
+                                          "H261AS",
+                                          90000,self.id),
+                               Capability( Capability.PRODUCER,
+                                          Capability.VIDEO,
+                                          "H261AS",
+                                          90000,self.id)                                          ]
+        
+        if IsWindows():
+            vic = "vic.exe"
+        else:
+            vic = "vic"
+
+        self.executable = os.path.join(os.getcwd(),vic)
+        if not os.path.isfile(self.executable):
+            self.executable = vic
+
+        self.sysConf = SystemConfig.instance()
+
+        self.startPriority = '5'
+        self.startPriorityOption.value = self.startPriority
+
+
+        # Set configuration parameters
+        # note: the datatype of the port parameter changes when a resource is set!
+        #
+        self.streamname = TextParameter( "Stream Name", "" )
+        self.port = TextParameter( "Port", "" )
+        self.encoding = OptionSetParameter( "Encoding", "mpeg4", VideoServiceH264.encodings )
+        if IsWindows(): 
+            standard = "PAL"
+        else:
+            standard = "auto"
+        self.standard = OptionSetParameter( "Standard", standard, VideoServiceH264.standards )
+        self.tiles = OptionSetParameter( "Thumbnail Columns", "4", VideoServiceH264.tileOptions )
+        self.bandwidth = RangeParameter( "Bandwidth", 4096, 0, 6144 )
+        self.framerate = RangeParameter( "Frame Rate", 24, 1, 30 )
+        self.quality = RangeParameter( "Quality", 75, 1, 100 )
+        self.inputsize = OptionSetParameter( "Capture Size", "Large", VideoServiceH264.inputsizes  )
+        self.transmitOnStart = OptionSetParameter( "Transmit on Startup", "On", VideoServiceH264.onOffOptions )
+        self.muteSources = OptionSetParameter( "Mute Sources", "Off", VideoServiceH264.onOffOptions )
+        self.configuration.append( self.streamname )
+        self.configuration.append( self.port )
+        self.configuration.append( self.encoding )
+        self.configuration.append( self.standard )
+        self.configuration.append( self.tiles )
+        self.configuration.append( self.bandwidth )
+        self.configuration.append( self.framerate )
+        self.configuration.append (self.quality )
+        self.configuration.append (self.inputsize )
+        self.configuration.append (self.transmitOnStart )
+        self.configuration.append (self.muteSources )
+
+        if IsWindows():
+            try:
+                import win32api
+
+                # get number of processors
+                systemInfo = win32api.GetSystemInfo()
+                numprocs = systemInfo[5]
+                self.allProcsMask = 2**numprocs-1
+
+                self.procOptions = ['All']
+                for i in range(numprocs):
+                    self.procOptions.append(str(i+1))
+
+                self.processorUsage = OptionSetParameter( "Processor usage", self.procOptions[0], self.procOptions )
+                self.configuration.append( self.processorUsage )
+            except:
+                self.log.exception('Error initializing processor usage options')
+
+        self.profile = None
+        self.resource = ''
+        
+        self.__GetResources()
+
+    def __SetRTPDefaults(self, profile):
+        """
+        Set values used by rat for identification
+        """
+        if profile == None:
+            self.log.exception("Invalid profile (None)")
+            raise Exception, "Can't set RTP Defaults without a valid profile."
+
+        if IsLinux() or IsOSX() or IsFreeBSD():
+            try:
+                rtpDefaultsFile=os.path.join(os.environ["HOME"], ".RTPdefaults")
+                rtpDefaultsText="*rtpName: %s\n*rtpEmail: %s\n*rtpLoc: %s\n*rtpPhone: \
+                                 %s\n*rtpNote: %s\n"
+                rtpDefaultsFH=open( rtpDefaultsFile,"w")
+                rtpDefaultsFH.write( rtpDefaultsText % ( profile.name,
+                                       profile.email,
+                                       profile.location,
+                                       profile.phoneNumber,
+                                       profile.publicId ) )
+                rtpDefaultsFH.close()
+            except:
+                self.log.exception("Error writing RTP defaults file: %s", rtpDefaultsFile)
+
+        elif IsWindows():
+            try:
+                #
+                # Set RTP defaults according to the profile
+                #
+                k = _winreg.CreateKey(_winreg.HKEY_CURRENT_USER,
+                                    r"Software\Mbone Applications\common")
+
+                # Vic reads these values (with '*')
+                _winreg.SetValueEx(k, "*rtpName", 0,
+                                   _winreg.REG_SZ, profile.name)
+                _winreg.SetValueEx(k, "*rtpEmail", 0,
+                                   _winreg.REG_SZ, profile.email)
+                _winreg.SetValueEx(k, "*rtpPhone", 0,
+                                   _winreg.REG_SZ, profile.phoneNumber)
+                _winreg.SetValueEx(k, "*rtpLoc", 0,
+                                   _winreg.REG_SZ, profile.location)
+                _winreg.SetValueEx(k, "*rtpNote", 0,
+                                   _winreg.REG_SZ, str(profile.publicId) )
+                _winreg.CloseKey(k)
+            except:
+                self.log.exception("Error writing RTP defaults to registry")
+        else:
+            self.log.error("No support for platform: %s", sys.platform)
+        
+    def MapWinDevice(self,deviceStr):
+        """
+        Abuse registry to get correct mapping from vfw names
+        to video sources
+        """
+        videowidth = 720
+        videoheight = 480
+        
+        self.log.info("Mapping windows device: %s", deviceStr)
+        if deviceStr.find('Videum') >= 0:
+            self.log.info("- videum")
+            devnum = -1
+            videum_re = re.compile(".*(\d)_Videum.*")
+            m = videum_re.search(deviceStr)
+            if m:
+                self.log.info("Found match : %d", int(m.group(1)))
+                devnum = int(m.group(1))
+            else:
+                self.log.info("No match")
+                if deviceStr.startswith('Videum Video Capture'):
+                    self.log.info("is videum video capture")
+                    devnum = 0
+                else:
+                    self.log.info("is not videum video capture")
+
+            self.log.info("Videum device: %d", devnum)
+            if devnum >= 0:
+                # Set the registry
+                keyStr = r"Software\Winnov\Videum\vic.exe%d" % (devnum,)
+                key = _winreg.CreateKey(_winreg.HKEY_CURRENT_USER,
+                                        keyStr)
+                _winreg.SetValueEx(key,'Source',0,_winreg.REG_DWORD,int(devnum))
+                _winreg.SetValueEx(key,'Height',0,_winreg.REG_DWORD,int(videoheight))
+                _winreg.SetValueEx(key,'Width',0,_winreg.REG_DWORD,int(videowidth))
+                _winreg.CloseKey(key)
+                
+
+    def Start( self ):
+        """Start service"""
+        try:
+
+            # Set processor affinity (windows only)
+            if IsWindows():
+                try:
+                    if self.processorUsage.value == 'All':
+                        self.log.info('Setting processor affinity to all processors')
+                        SystemConfig.instance().SetProcessorAffinity(self.allProcsMask)
+                    else:
+                        val = 2**(int(self.processorUsage.value)-1)
+                        self.log.info('Ssetting processor affinity : use processor %s', self.processorUsage.value)
+                        SystemConfig.instance().SetProcessorAffinity(int(self.processorUsage.value))
+                except:
+                    self.log.exception("Exception setting processor affinity")
+            
+            # Enable firewall
+            self.sysConf.AppFirewallConfig(self.executable, 1)
+
+            # Resolve assigned resource to a device understood by vic
+            if self.resource == "None":
+                vicDevice = "None"
+            else:
+                vicDevice = self.resource[0]
+                vicDevice = vicDevice.replace("[","\[")
+                vicDevice = vicDevice.replace("]","\]")
+
+            if IsWindows():
+                try:
+                    self.MapWinDevice(self.resource[0])
+                except:
+                    self.log.exception("Exception mapping device")
+
+
+            #
+            # Write vic startup file
+            #
+            startupfile = os.path.join(UserConfig.instance().GetTempDir(),
+               'VideoServiceH264%d.vic' % ( os.getpid() ) )
+
+            f = open(startupfile,"w")
+            if self.port.value == '':
+                portstr = "None"
+            else:
+                portstr = self.port.value
+            
+            if self.muteSources.value == "On":
+                # streams are muted, so disable autoplace
+                disableAutoplace = "true"
+            else:
+                # streams are not muted, so don't disable autoplace
+                # (flags should not be negative!)
+                disableAutoplace = "false"
+
+            name=email="Participant"
+            if self.profile:
+                name = self.profile.name
+                email = self.profile.email
+            else:
+                # Error case
+                name = email = Toolkit.GetDefaultSubject().GetCN()
+                self.log.error("Starting service without profile set")
+
+            if self.inputsize.value == "Small":
+                inputsize = 4
+            elif self.inputsize.value == "Normal":
+                inputsize = 2
+            elif self.inputsize.value == "Large":
+                if self.encoding.value == "h261":
+                    self.log.warn("Invalid capture size (large) specified for h261 encoding; defaulting to normal size")
+                    inputsize = 2
+                else:
+                    inputsize = 1
+                
+            f.write( vicstartup % ( disableAutoplace,
+                                    OnOff(self.muteSources.value),
+                                    self.bandwidth.value,
+                                    self.framerate.value,
+                                    self.quality.value,
+                                    self.encoding.value,
+                                    self.standard.value,
+                                    vicDevice,
+                                    "%s(%s)" % (name,self.streamname.value),
+                                    email,
+                                    email,
+                                    OnOff(self.transmitOnStart.value),
+                                    portstr,
+                                    portstr,
+                                    inputsize) )
+            f.close()
+            
+            # Open permissions on vic startupfile
+            os.chmod(startupfile,0777)
+
+            # Replace double backslashes in the startupfile name with single
+            #  forward slashes (vic will crash otherwise)
+            if IsWindows():
+                startupfile = startupfile.replace("\\","/")
+            
+            #
+            # Start the service; in this case, store command line args in a list and let
+            # the superclass _Start the service
+            options = []
+            options.append( "-u" )
+            options.append( startupfile )
+            options.append( "-C" )
+            options.append( str(self.streamname.value) )
+            if IsOSX():
+                options.append( "-X")
+                options.append( "transmitOnStartup=1")
+            if self.streamDescription.encryptionFlag != 0:
+                options.append( "-K" )
+                options.append( self.streamDescription.encryptionKey )
+                
+            if self.profile:
+                options.append("-X")
+                options.append("site=%s" % self.profile.publicId)
+                
+            # Set number of columns to use for thumbnail display
+            options.append("-Xtile=%s" % self.tiles.value)
+
+            # Check whether the network location has a "type" attribute
+            # Note: this condition is only to maintain compatibility between
+            # older venue servers creating network locations without this attribute
+            # and newer services relying on the attribute; it should be removed
+            # when the incompatibility is gone
+            if self.streamDescription.location.__dict__.has_key("type"):
+                # use TTL from multicast locations only
+                if self.streamDescription.location.type == MulticastNetworkLocation.TYPE:
+                    options.append( "-t" )
+                    options.append( '%d' % (self.streamDescription.location.ttl) )
+            options.append( '%s/%d' % ( self.streamDescription.location.host,
+                                           self.streamDescription.location.port) )
+
+            self.log.info("Starting VideoServiceH264")
+            self.log.info(" executable = %s" % self.executable)
+            self.log.info(" options = %s" % options)
+            self._Start( options )
+            #os.remove(startupfile)
+        except:
+            self.log.exception("Exception in VideoServiceH264.Start")
+            raise Exception("Failed to start service")
+
+    def Stop( self ):
+        """Stop the service"""
+
+        # vic doesn't die easily (on linux at least), so force it to stop
+        AGService.ForceStop(self)
+
+        # Disable firewall
+        self.sysConf.AppFirewallConfig(self.executable, 0)
+
+    def SetStream( self, streamDescription ):
+        """Configure the Service according to the StreamDescription"""
+        self.log.info('SetStream: %s', streamDescription)
+        self.log.info('  enabled: %d', self.enabled)
+
+        ret = AGService.ConfigureStream( self, streamDescription )
+        if ret and self.started:
+            # service is already running with this config; ignore
+            return
+
+        # if started, stop
+        if self.started:
+            self.Stop()
+
+        # if enabled, start
+        if self.enabled:
+            self.Start()
+
+    def GetResource( self ):
+        if self.resource:
+            return ResourceDescription(self.resource[0])
+        else:
+            return ResourceDescription('')
+
+    def SetResource( self, resource ):
+        """Set the resource used by this service"""
+
+        self.log.info("VideoServiceH264.SetResource : %s" % resource.name)
+        for r in self.resources:
+            if r[0].strip() == resource.name:
+                self.resource = r
+
+        # Find the config element that refers to "port"
+        try:
+            index = self.configuration.index(self.port)
+            found = 1
+        except ValueError:
+            found = 0
+
+        # Create the port parameter as an option set parameter, now
+        # that we have multiple possible values for "port"
+        # If self.port is valid, keep it instead of setting the default value.
+        if (( isinstance(self.port, TextParameter) or isinstance(self.port, ValueParameter) ) 
+              and self.port.value != "" and self.port.value in self.resource[1]):
+            self.port = OptionSetParameter( "Port", self.port.value,
+                                                         self.resource[1] )
+        else:
+            self.port = OptionSetParameter( "Port", self.resource[1][0],
+                                                         self.resource[1] )
+
+        self.log.info('port = %s', self.port.value)
+
+        # Replace or append the "port" element
+        if found:
+            self.configuration[index] = self.port
+        else:
+            self.configuration.append(self.port)
+
+        # If the stream name has not been set, set it to the resource name
+        if not self.streamname.value:
+            self.streamname.value = resource.name
+
+    def SetIdentity(self, profile):
+        """
+        Set the identity of the user driving the node
+        """
+        self.log.info("SetIdentity: %s %s", profile.name, profile.email)
+        self.profile = profile
+        self.__SetRTPDefaults(profile)
+        
+    def GetResources(self):
+        ret = map(lambda x: ResourceDescription(x[0]) , self.resources)
+        self.log.info('resources: %s', ret)
+        return ret
+
+    def __GetResources(self):
+        self.resources = SystemConfig.instance().GetResources()
+        return self.resources
+        
+
+
+
+if __name__ == '__main__':
+
+    from AccessGrid.interfaces.AGService_interface import AGService as AGServiceI
+    from AccessGrid.AGService import RunService
+
+    service = VideoServiceH264()
+    serviceI = AGServiceI(service)
+    RunService(service,serviceI)
diff -urNad accessgrid3.1-3.1~/AccessGrid/services/node/VideoServiceH264/VideoServiceH264.svc accessgrid3.1-3.1/AccessGrid/services/node/VideoServiceH264/VideoServiceH264.svc
--- accessgrid3.1-3.1~/AccessGrid/services/node/VideoServiceH264/VideoServiceH264.svc	1970-01-01 10:00:00.000000000 +1000
+++ accessgrid3.1-3.1/AccessGrid/services/node/VideoServiceH264/VideoServiceH264.svc	2008-03-17 10:33:39.000000000 +1000
@@ -0,0 +1,16 @@
+[ServiceDescription]
+name = VideoServiceH264
+description = Vic-based video service using h264 and mpeg4
+capabilities = Capability1 Capability2
+executable = VideoServiceH264.py
+platform = neutral
+version = 3.11
+
+[Capability1]
+role = producer
+type = video
+
+[Capability2]
+role = consumer
+type = video
+
